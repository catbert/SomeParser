using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace SomeParser.Tokenizer
{
    /// <summary>
    /// Finishes the parsing
    /// </summary>
    class RuleNumber : Rule[TokenizerState]
    {
        
        // priority 5
        public this()
        {
            base(5);
        }
        
        // is applicable if char is sign
        public override IsApplicable(engine : RuleEngine[TokenizerState]) : bool
        {
            def symbol = engine.Data.RemainingText[0];
            def nextSymbol = if (engine.Data.RemainingText.Length > 1) engine.Data.RemainingText[1] else 0 :> char;
            
            match (symbol, nextSymbol)
            {
                | (x, _) when Char.IsDigit(x)
                
                | ('+', x)
                | ('-', x)
                | ('.', x)
                    => Char.IsDigit(x)
                
                | ('+', '.')
                | ('-', '.') => true
                
                | _ => false
            }
        }
        
        // stops engine
        public override Apply(engine : RuleEngine[TokenizerState]) : void
        {   
            def text = engine.Data.RemainingText;
                
            mutable i = 0;
            mutable state = 0; // 0 - at sign, 1 - at int, 2 - at dot, 3 - at dec, 4 - at e, 5 - at expsign, 6 - at exp
            mutable error = false;
            
            result : {
                
                
                while (i < text.Length)
                {
                    def symbol = text[i];
                    def nextSymbol = if (i + 1 < text.Length) text[i + 1] else 0 :> char;
                    
                    match (state, symbol, nextSymbol)
                    {
                        // 0 - at sign
                        | (0, '+', _) 
                        | (0, '-', _) => state = 1; i++;
                        
                        | (0, '.', _) => state = 2;
                        
                        | (0,  d , _) when Char.IsDigit(d) => state = 1;
                        
                        | (0,  _ , _) => error = true; result(i)
                    }
                }
            }
        }
        
    }
}
